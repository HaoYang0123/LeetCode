// Leetcode 2193

class Solution {
public:
    int minMovesToMakePalindrome(string s) {
        int i=0, j=s.length()-1, res=0;
        //贪心策略，i从左往右扫、j从右往左扫
        //[i,j]表示s[i...j]转成回文串的最小次数
        //s[i]，从j往左扫，找到最右第1个(比如：k)与s[i]相等
        //那么需要将s[k]与s[k+1]交换，不停与右边元素交换
        //止到s[k]交换至s[j]位置，这样s[i]==s[j]
        //那么继续走s[i+1...j-1]
        //注：如果s长度是偶数次，那么所有字符一定出现了偶数次
        //注：如果s长度是奇数次，那么只有一个字符出现了奇数次（不然，不能形成回文串）
        for(; i<j; ++i) {  //维持好s[i...j]，找当前子字符串，转化成回串的最小次数
            bool is_find = false;  //表示是否找到了与s[i]相等的最右边的位置
            int k=j;  //k表示找到的位置，先从最右边开始找起
            for(; k>i; --k) {  // 一路往左扫
                if(s[k] == s[i]) {  //如果找到了，则break
                    is_find = true;
                    break;
                }
            }
            if(is_find) {  //找到了，说明s[i]是出现偶数次的字符
                for(; k<j; ++k) {  //将s[k...j]两两交换（即s[k]与s[k+1]交换、s[k+1]与s[k+2]交换...)，这样保证最后与s[i]相同的元素从k位置移到了j位置
                    swap(s[k], s[k+1]);
                    ++res;  //每次移动，需要对结果+1步
                }
                --j;  //由于s[i]与s[j]相等了，--j
            }
            else {  //如果没找到与s[i]相等的字符，s[i]一定就是出现奇数次的字符
                res += (s.length()/2 - i);  //模拟将奇数次的字符，移到中间位置
                //注：这里不是真的移动此字符，因为下一个for循环,++i了，而j没更新，简单地将s[i]给“丢弃”了（移至中间位置）
            }
        }
        return res;
    }
};
