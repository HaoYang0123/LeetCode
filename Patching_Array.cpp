//Leetcode 330
//这里用的是网上的代码，但是我这里加了注释

class Solution {
public:
    int minPatches(vector<int>& nums, int n) { //nums是从小到大排序的
        //auto dp = vector<bool> (n+1, false);
        // dp[0] = true;
        long long minT = 0; //当前将nums[0:i](加上需要插入的元素)求和，
        int ret = 0;
        for(int i=0;minT<n;){
            if(i<nums.size()&&nums[i]<=(minT+1)) 
                minT+=nums[i++]; //nums[i]当前元素比minT+1小，意味着不用插入元素，并且更新当前求和，i++指向下一个元素
            else { 
                //nums[i]比minT+1大，则表示从minT+1至nums[i]需要插入一个元素（所以res++）
                //这里先插入的元素为minT+1，同时更新minT（将新插入的minT+1加进去）
                minT+=(minT+1);
                ret++;
            }
        }
        //举个例子：[1,100],n=200，minT为0，i为0，nums[0]=1<=(minT+1)，则更新minT为1（表示当前元素为1，不用插入，当前求和为1）
        //i更新为1，nums[1]=100>minT (minT当前为1)，则需要插入元素2（res++），同时更新minT=3
        //上面解释一下：因为插入了2，nums变为[1,2...]，1和2存在，意味着[1,2,3]均可以得到
        //i不更新，仍然为1，nums[1]=100>minT (minT当前为3)，则需要插入4 （res++），同时更新minT=3+4=7
        //上面再解释一下：因为继续插入了4，nums变为[1,2,4...]，1,2,4均存在的情况下，意味从1至7的所有数字均可以得到（读者自己可以试试）
        //后面依次类推，会插入8,16,32,64（可以看出来是2的进制）
        //最后插入64后，minT更新为127，这里nums[1]=100<=minT+1=128，则不用再继续插入128了，同时更新minT=127+100=227
        //即此时nums拥有[1,2,4,8,16,32,64,100],选择多个元素求和，可以得到1至227中的任意值
        //最后minT已经大于n=200，则退出
        //当然，如果n变为300，则for仍然继续，由于i已经>=nums.size()，所以if永远也不满足条件，所以一直会走else
        //这就导致下一个插入的元素为228（因为之前1至227的任意值已经可以处理，下一个元素为228）
        //继续更新minT=227+228=455，最后455>300，算法终止
        return ret;
    }
};
